<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HotSauce MCF - Search & Dive</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        
        #overlay { position: absolute; top: 20px; left: 20px; color: #0f0; pointer-events: none; text-shadow: 0 0 5px #0f0; }
        
        #search-container { 
            position: absolute; top: 20px; right: 20px; 
            background: rgba(0, 40, 0, 0.8); padding: 10px; 
            border: 1px solid #0f0; box-shadow: 0 0 10px #0f0;
        }
        
        input { 
            background: #000; border: 1px solid #0f0; color: #0f0; 
            padding: 5px; outline: none; font-family: monospace; text-transform: uppercase;
        }

        #hint { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #005500; font-size: 12px; pointer-events: none; }
        canvas { display: block; cursor: crosshair; }
    </style>
</head>
<body>
    <div id="overlay">
        <h2 style="margin:0">MCF NAVIGATOR</h2>
        <div id="status">Target: MCF_CORE</div>
    </div>

    <div id="search-container">
        <input type="text" id="searchBar" placeholder="SEARCH TAGS..." autocomplete="off">
    </div>

    <div id="hint">CLICK TAGS OR USE SEARCH â€¢ [SPACE] TO RESET</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "tween": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'tween';

        // --- Data ---
        const DATA_TREE = {
            name: "MCF_CORE",
            children: [
                { name: "DOCUMENTS", children: ["Resume.mcf", "Budget.mcf", "Drafts", "Legacy"] },
                { name: "APPLICATIONS", children: ["Finder 3D", "HotSauce", "Browser", "Terminal"] },
                { name: "NETWORK", children: ["Servers", "Clients", "Nodes", "Protocols"] },
                { name: "RESOURCES", children: ["Images", "Audio", "Textures", "Fonts"] }
            ]
        };

        let scene, camera, renderer, controls, raycaster, mouse;
        const clickableObjects = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 400, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // 1. Build the Root
            const rootLabel = createTextLabel(DATA_TREE.name, "#ffffff", 2);
            rootLabel.userData = { name: DATA_TREE.name };
            scene.add(rootLabel);
            clickableObjects.push(rootLabel);

            // 2. Build Hierarchy
            DATA_TREE.children.forEach((cat, i) => {
                const angle = (i / DATA_TREE.children.length) * Math.PI * 2;
                const dist = 500;
                
                const group = new THREE.Group();
                group.position.set(Math.cos(angle) * dist, Math.sin(angle) * 150, Math.sin(angle) * dist);
                scene.add(group);

                const catLabel = createTextLabel(cat.name, "#00ff00", 1.5);
                catLabel.userData = { name: cat.name };
                group.add(catLabel);
                clickableObjects.push(catLabel);

                cat.children.forEach((child, j) => {
                    const cAngle = (j / cat.children.length) * Math.PI * 2;
                    const cDist = 150;
                    const childLabel = createTextLabel(child, "#00aaaa", 0.9);
                    childLabel.position.set(Math.cos(cAngle) * cDist, Math.sin(cAngle) * cDist, 0);
                    childLabel.userData = { name: child };
                    group.add(childLabel);
                    clickableObjects.push(childLabel);
                });
            });

            // Events
            window.addEventListener('click', onDocumentClick);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => { if(e.code === 'Space') resetCamera(); });
            
            // Search functionality
            document.getElementById('searchBar').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const term = e.target.value.toUpperCase();
                    const match = clickableObjects.find(obj => obj.userData.name.toUpperCase() === term);
                    if (match) {
                        const targetPos = new THREE.Vector3();
                        match.getWorldPosition(targetPos);
                        diveTo(targetPos, match.userData.name);
                        e.target.value = "";
                        e.target.blur();
                    } else {
                        e.target.style.borderColor = "red";
                        setTimeout(() => e.target.style.borderColor = "#0f0", 500);
                    }
                }
            });
        }

        function createTextLabel(text, color, scale) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            
            ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, 256, 64);
            
            ctx.font = 'bold 26px monospace';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(100 * scale, 25 * scale, 1);
            return sprite;
        }

        function onDocumentClick(event) {
            if (event.target.tagName === 'INPUT') return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                const targetPos = new THREE.Vector3();
                target.getWorldPosition(targetPos);
                diveTo(targetPos, target.userData.name);
            }
        }

        function diveTo(position, name) {
            document.getElementById('status').innerText = "Target: " + name;
            
            // Calculate a point slightly in front of the target
            const direction = new THREE.Vector3().subVectors(camera.position, position).normalize();
            const newPos = new THREE.Vector3().addVectors(position, direction.multiplyScalar(200));

            new TWEEN.Tween(camera.position)
                .to({ x: newPos.x, y: newPos.y, z: newPos.z }, 1200)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();

            new TWEEN.Tween(controls.target)
                .to({ x: position.x, y: position.y, z: position.z }, 1200)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        function resetCamera() {
            diveTo(new THREE.Vector3(0, 0, 0), "MCF_CORE");
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            // Subtle pulse effect for the labels
            const s = 1 + Math.sin(time * 0.005) * 0.02;
            clickableObjects.forEach(obj => {
                // We preserve the base scale multipliers set during creation
                // Base scales are 2, 1.5, or 0.9 based on depth
            });

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>